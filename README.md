# LowTHelpEachOther
This repository just for LowT(Bob &amp; Tsingwong)

# 2020 年

## 2020 年 04 月

### 2020 年04 月 07 日

#### Bob: JAVA 中 Array 与 ArrayList 的差异
大部分语言（不包含 JavaScript）中的 Array 长度都是数组的属性之一，故不同长度的数组是不同类型的数组。

这一点的好处虽然她说不出来，但是缺点是给数组的增删造成了一定的困扰。

于是 ArrayLis 产生了，底层还是调用的 Array ，简单可以理解为随着数组长度的变化，当数组长度不够用的时候，ArrayList 会把当前底层的 Array 复制到另一个足够存放这些数据的 Array 中。

举个栗子，之前是长度为 2 的 ArrayList，存放了两个数字，这时候想在往里面存放一个数字时，ArrayList 的长度可能就会变成 4 ，以动态地满足其长度。

补充知识：
- 其他语言中也存在类似的，如 go 中的 array 和 slice
- ArrayList 的底层操作中存在一个赋值操作，即将变量名指向新数组的内存地址的操作；这个在数据中可以引申出：有哪些方法是改变数组本身，有哪些是不改变数组本身的？

#### Tsingwong: 词法作用域与动态作用域

作用域：可以理解为**引擎如何查找变量**以及**在何处找到变量**的规则。例如当前函数中需要有个参数 a，那么应该怎么查找这个 a，然后去哪里查找这个 a 呢？

大部分我们熟知的语言都是词法作用域（也被成为是静态作用域），有少部分语言使用的是动态作用域（Pascal、Emacs Lisp 等）

先来阐述下概念
- 词法作用域是词法变量在编译时静态确定的，所以它关注的是：**在何处定义声明的**
- 动态作用域是动态变量在运行时被动态确定的，所以它关注的是： **在何处被调用**，基于调用栈

举个栗子：

```javascript
function foo() {
  console.log( a );
}
function bar() {
  var a = 3;
	foo();
}
var a = 2;
bar();
```

这里是一段 JavaScript 代码。

假设 JavaScript 是词法作用域（当然不用假设，它就是），词法作用域关注声明在何处，`foo` 内部存在一个作用域，这里面显然查找不到 `a`，`foo` 声明在全局作用域，所以继续在全局作用域找到 `a = 2`，所以这里输出的结果是 2。

那么假设 JavaScript 是动态作用域（这次是真的假设了），动态作用域关注是调用位置，函数的调用栈是：`global -> bar -> foo`，那么同样的在 `foo` 内部查找不到 `a`，这时候会沿着调用栈查找，于是会在 `bar` 中找到 `a`，所以这里输出的结果是 3。

遮蔽效应：作用域查找到第一个匹配的变量后停止，内层的变量会“遮蔽”外层的同名变量。
